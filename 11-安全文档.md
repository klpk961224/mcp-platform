# å®‰å…¨æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **é¡¹ç›®åç§°**ï¼šä¼ä¸šçº§AIç»¼åˆç®¡ç†å¹³å°
- **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0
- **åˆ›å»ºæ—¥æœŸ**ï¼š2026-01-13
- **æ–‡æ¡£ç±»å‹**ï¼šå®‰å…¨æ–‡æ¡£

---

## 1. å®‰å…¨æ¶æ„è®¾è®¡

### 1.1 å®‰å…¨æ¶æ„å›¾

```mermaid
graph TB
    A[å®¢æˆ·ç«¯] --> B[HTTPSåŠ å¯†]
    B --> C[APIç½‘å…³]
    C --> D[é™æµç†”æ–­]
    D --> E[è®¤è¯æˆæƒ]
    E --> F[æƒé™æ ¡éªŒ]
    F --> G[åº”ç”¨æœåŠ¡]
    G --> H[æ•°æ®åŠ å¯†]
    G --> I[SQLæ³¨å…¥é˜²æŠ¤]
    G --> J[XSSé˜²æŠ¤]
```

### 1.2 å®‰å…¨å±‚æ¬¡

| å±‚æ¬¡ | å®‰å…¨æªæ–½ |
|-----|---------|
| **ä¼ è¾“å±‚** | HTTPS/TLS 1.3 |
| **ç½‘å…³å±‚** | é™æµç†”æ–­ã€IPç™½åå• |
| **è®¤è¯å±‚** | JWT + API KeyåŒè®¤è¯ |
| **æˆæƒå±‚** | RBAC + ABACæƒé™æ¨¡å‹ |
| **åº”ç”¨å±‚** | å‚æ•°éªŒè¯ã€æ•°æ®åŠ å¯† |
| **æ•°æ®å±‚** | æ•æ„Ÿæ•°æ®åŠ å¯†ã€SQLæ³¨å…¥é˜²æŠ¤ |

---

## 2. è®¤è¯æˆæƒæœºåˆ¶

### 2.1 JWTè®¤è¯

```python
# auth/jwt_handler.py
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440

def create_access_token(data: dict):
    """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    """éªŒè¯ä»¤ç‰Œ"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None

def get_password_hash(password: str):
    """è·å–å¯†ç å“ˆå¸Œ"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str):
    """éªŒè¯å¯†ç """
    return pwd_context.verify(plain_password, hashed_password)
```

### 2.2 API Keyè®¤è¯

```python
# auth/api_key_handler.py
import secrets
from typing import Optional
from sqlalchemy.orm import Session
from app.models.api_key import ApiKey

def generate_api_key(prefix: str = "agent") -> str:
    """ç”ŸæˆAPI Key"""
    random_part = secrets.token_urlsafe(32)
    return f"{prefix}_{random_part}"

def verify_api_key(api_key: str, db: Session) -> Optional[dict]:
    """éªŒè¯API Key"""
    key_obj = db.query(ApiKey).filter(
        ApiKey.key == api_key,
        ApiKey.is_active == True
    ).first()
    
    if not key_obj:
        return None
    
    if key_obj.is_expired():
        return None
    
    return {
        "id": key_obj.id,
        "user_id": key_obj.user_id,
        "scopes": key_obj.scopes
    }
```

---

## 3. æ•°æ®åŠ å¯†æ–¹æ¡ˆ

### 3.1 æ•æ„Ÿæ•°æ®åŠ å¯†

```python
# utils/crypto.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

# åŠ å¯†å¯†é’¥
ENCRYPTION_KEY = b'your-encryption-key-here-32-bytes-long'

# åˆ›å»ºåŠ å¯†å™¨
cipher_suite = Fernet(ENCRYPTION_KEY)

def encrypt_data(data: str) -> str:
    """åŠ å¯†æ•°æ®"""
    encrypted = cipher_suite.encrypt(data.encode())
    return base64.urlsafe_b64encode(encrypted).decode()

def decrypt_data(encrypted_data: str) -> str:
    """è§£å¯†æ•°æ®"""
    encrypted = base64.urlsafe_b64decode(encrypted_data.encode())
    decrypted = cipher_suite.decrypt(encrypted)
    return decrypted.decode()

# å¯†ç åŠ å¯†
def hash_password(password: str) -> str:
    """å¯†ç å“ˆå¸Œ"""
    import bcrypt
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

def verify_password(plain: str, hashed: str) -> bool:
    """éªŒè¯å¯†ç """
    import bcrypt
    return bcrypt.checkpw(plain.encode(), hashed.encode())
```

### 3.2 ä¼ è¾“åŠ å¯†

```python
# é…ç½®HTTPS
from fastapi import FastAPI
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

app = FastAPI()

# å¼ºåˆ¶HTTPS
app.add_middleware(HTTPSRedirectMiddleware)

# é…ç½®SSL/TLS
# åœ¨ç”Ÿäº§ç¯å¢ƒé…ç½®æœ‰æ•ˆçš„SSLè¯ä¹¦
```

---

## 4. SQLæ³¨å…¥é˜²æŠ¤

### 4.1 å‚æ•°åŒ–æŸ¥è¯¢

```python
# é”™è¯¯ç¤ºä¾‹ï¼ˆæ˜“å—SQLæ³¨å…¥ï¼‰
def get_user_by_username(username: str):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    # å¦‚æœusernameåŒ…å«æ¶æ„SQLä»£ç ï¼Œä¼šå¯¼è‡´SQLæ³¨å…¥

# æ­£ç¡®ç¤ºä¾‹ï¼ˆå‚æ•°åŒ–æŸ¥è¯¢ï¼‰
def get_user_by_username(username: str):
    from sqlalchemy import text
    query = text("SELECT * FROM users WHERE username = :username")
    result = db.execute(query, {"username": username})
    return result.fetchall()

# ä½¿ç”¨ORM
def get_user_by_username(username: str):
    user = db.query(User).filter(User.username == username).first()
    return user
```

### 4.2 è¾“å…¥éªŒè¯

```python
from pydantic import validator, BaseModel

class UserCreateRequest(BaseModel):
    username: str
    email: str
    password: str
    
    @validator('username')
    def validate_username(cls, v):
        if not v.isalnum():
            raise ValueError('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯å’Œæ•°å­—')
        if len(v) < 3 or len(v) > 50:
            raise ValueError('ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨3-50ä¹‹é—´')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        import re
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_regex, v):
            raise ValueError('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®')
        return v
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('å¯†ç é•¿åº¦ä¸èƒ½å°‘äº8ä½')
        if not any(c.isupper() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯')
        if not any(c.islower() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯')
        if not any(c.isdigit() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«æ•°å­—')
        return v
```

---

## 5. XSSé˜²æŠ¤

### 5.1 è¾“å‡ºç¼–ç 

```python
from html import escape

def render_user_comment(comment: str) -> str:
    """æ¸²æŸ“ç”¨æˆ·è¯„è®ºï¼Œé˜²æ­¢XSSæ”»å‡»"""
    # è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦
    safe_comment = escape(comment)
    return safe_comment
```

### 5.2 CSPç­–ç•¥

```python
# é…ç½®Content Security Policy
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app = FastAPI()

# CSPå¤´
@app.middleware("http")
async def add_security_headers(request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Content-Security-Policy"] = "default-src 'self'"
    return response
```

---

## 6. CSRFé˜²æŠ¤

### 6.1 CSRF Token

```python
from fastapi import Depends, HTTPException, Request
from starlette.middleware.base import BaseHTTPMiddleware
import secrets

class CSRFMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, request.call_next):
        if request.method in ["POST", "PUT", "DELETE", "PATCH"]:
            csrf_token = request.cookies.get("csrf_token")
            if not csrf_token:
                raise HTTPException(status_code=403, detail="CSRF token missing")
            
            # éªŒè¯CSRF token
            if not secrets.compare_digest(
                csrf_token,
                request.headers.get("X-CSRF-Token", "")
            ):
                raise HTTPException(status_code=403, detail="Invalid CSRF token")
        
        response = await request.call_next(request)
        return response

app.add_middleware(CSRFMiddleware)
```

---

## 7. APIå®‰å…¨è§„èŒƒ

### 7.1 é™æµé˜²æŠ¤

```python
from slowapi import Limiter, _rate_for
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse

limiter = Limiter(key_func=_rate_for)

@app.get("/api/v1/users")
@limiter.limit("100/minute")
async def get_users(request: Request):
    """è·å–ç”¨æˆ·åˆ—è¡¨ï¼Œé™æµï¼šæ¯åˆ†é’Ÿ100æ¬¡"""
    users = user_service.get_users()
    return JSONResponse(content=users)
```

### 7.2 è¯·æ±‚å¤§å°é™åˆ¶

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.middleware("http")
async def limit_request_size(request: Request, call_next):
    content_length = request.headers.get("content-length")
    if content_length and int(content_length) > 10 * 1024 * 1024:  # 10MB
        raise HTTPException(status_code=413, detail="è¯·æ±‚ä½“è¿‡å¤§")
    return await call_next(request)
```

---

## 8. å®‰å…¨å®¡è®¡æ—¥å¿—

### 8.1 å®¡è®¡æ—¥å¿—è®°å½•

```python
# utils/audit_logger.py
from loguru import logger
from datetime import datetime

class AuditLogger:
    @staticmethod
    def log_operation(
        user_id: str,
        tenant_id: str,
        operation: str,
        resource: str,
        result: str,
        details: dict = None
    ):
        """è®°å½•æ“ä½œæ—¥å¿—"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "user_id": user_id,
            "tenant_id": tenant_id,
            "operation": operation,
            "resource": resource,
            "result": result,
            "details": details or {}
        }
        logger.info(f"AUDIT: {log_data}")
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        # audit_log_service.create(log_data)
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [æŠ€æœ¯æ¶æ„è®¾è®¡æ–‡æ¡£](./2-æŠ€æœ¯æ¶æ„è®¾è®¡æ–‡æ¡£.md)
- [è¿ç»´æ–‡æ¡£](./10-è¿ç»´æ–‡æ¡£.md)
- [æ€§èƒ½ä¼˜åŒ–æ–‡æ¡£](./12-æ€§èƒ½ä¼˜åŒ–æ–‡æ¡£.md)

---

## ğŸ’¡ æ³¨æ„äº‹é¡¹

1. **å¯†é’¥ç®¡ç†**ï¼šä¸è¦åœ¨ä»£ç ä¸­ç¡¬ç¼–ç å¯†é’¥ï¼Œä½¿ç”¨ç¯å¢ƒå˜é‡
2. **å®šæœŸæ›´æ–°**ï¼šå®šæœŸæ›´æ–°ä¾èµ–åº“ï¼Œä¿®å¤å®‰å…¨æ¼æ´
3. **å®‰å…¨å®¡è®¡**ï¼šå®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡å’Œæ¸—é€æµ‹è¯•
4. **æƒé™æœ€å°åŒ–**ï¼šéµå¾ªæœ€å°æƒé™åŸåˆ™
5. **å®‰å…¨åŸ¹è®­**ï¼šå®šæœŸè¿›è¡Œå®‰å…¨åŸ¹è®­å’Œæ„è¯†æ•™è‚²

---

**æ–‡æ¡£ç‰ˆæœ¬å†å²**ï¼š

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|-----|------|------|---------|
| v1.0 | 2026-01-13 | AIåŠ©æ‰‹ | åˆå§‹ç‰ˆæœ¬ |

---